**Rd. 917 (div.2)**
===

## [C: Watering an Array](https://codeforces.com/problemset/problem/1917/C)

<details>
  <summary>tags</summary>
  
    | brute force | greedy |

</details>

<details>
  <summary>solution</summary>

    Easily seen that if we start with a = {0, 0, ..., 0}, the maximum score d / 2 is achieved by alternate reset and addition.
    So the target is to decide when to reset a to all zeros for the first time? How many cases to enumerate?
    For the first reset, obviously we can only get at most n scores. When will the all-zeros approach outperform it?
    After 2n days, the all-zeros approach will get n scores. So, only enumerate cases where first reset is earlier than 2n + 1 days.
    
</details>

<details>
  <summary>code</summary>

  ```c++
  int main () {
      ios::sync_with_stdio(false); cin.tie(0);
      int t;  cin >> t;
      while (t--) {
          int n, k, d;  cin >> n >> k >> d;
          vector<int> a(n + 1), v(k);
          int score = 0, maxscore = 0;
          for (int i = 1; i <= n; i++) {
              cin >> a[i];
              if (a[i] == i) score++;
          }
          for (int i = 0; i < k; i++) cin >> v[i];
          
          for (int day = 0; day <= min(2 * n, d - 1); day++) {  // accumulate for days, reset on day+1
              maxscore = max(maxscore, score + (d - day - 1) / 2);
  
              int idx = day % k; 
              for (int j = 1; j <= v[idx]; j++) {
                  if (a[j] == j) score--;
                  a[j]++;
                  if (a[j] == j) score++;
              }            
          }
          cout << maxscore << '\n';
      }
  }
  ```

</details>

<br>

## [D: Yet Another Inversions Problem](https://codeforces.com/problemset/problem/1917/D)

> Goddamn this is real hard

<details>
  <summary>tags</summary>
  
    | Binary Indexed Tree | Segment Tree |

</details>

<details>
  <summary>solution</summary>

    Let's split the full array into parts of length k, which each corresponds to one certain element in p.
    Easily seen that q contributs to same number of inversions in every k-segment.
    Use BIT to count it, and times it n. These are inversions within each k-segment.

    As for those inversions between different segments...
    Ã„hh I don't feel like explaining it, in case I forget how to do it, refer to 
    [this really nice blog](https://blog.csdn.net/m0_73500785/article/details/135277732).
    
</details>

<details>
  <summary>code</summary>

  ```c++
  const ll mod = 998244353;
  
  ll lowbit(ll x) {
      return x & (-x);
  }
  
  void bitUpdate(vector<ll>& BIT, ll x) {
      while (x < BIT.size()) {
          BIT[x]++;
          x += lowbit(x);
      }
  }
  
  ll bitQuery(vector<ll>& BIT, ll x) {
      ll sum = 0;
      while (x > 0) {
          sum += BIT[x];
          x -= lowbit(x);
      }
      return sum;
  }
  
  void stUpdate(vector<ll>& ST, int idx, int l, int r, ll x) {
      if (l == r - 1) {
          ST[idx]++;
          return;
      }
      int mid = (l + r) >> 1;
      if (x < mid) stUpdate(ST, idx << 1, l, mid, x);
      else stUpdate(ST, (idx << 1) + 1, mid, r, x);
      ST[idx] = ST[idx << 1] + ST[(idx << 1) + 1];
  }
  
  ll stQuery(vector<ll>& ST, int idx, int l, int r, int L, int R) {
      if (L <= l && R >= r) return ST[idx];
      if (L >= r || R <= l) return 0;
      ll sum = 0;
      int mid = (l + r) >> 1;
      if (L < mid) sum += stQuery(ST, idx << 1, l, mid, L, R);
      if (R > mid) sum += stQuery(ST, (idx << 1) + 1, mid, r, L, R);
      return sum;
  }
  
  ll solve () {
      int n, k;  cin >> n >> k;
      vector<ll> p(n + 1), q(k + 1);
      ffor(1, n + 1, 1) cin >> p[i];
      ffor(1, k + 1, 1) cin >> q[i];
  
      vector<ll> BIT(k + 1);
      ll sum = 0;
      ffor(1, k + 1, 1) {
          sum = (sum + bitQuery(BIT, k) - bitQuery(BIT, q[i] + 1) + mod) % mod;
          bitUpdate(BIT, q[i] + 1);
      }
      sum = (sum * n) % mod;
  
      vector<ll> ST(8 * n);
      stUpdate(ST, 1, 1, 2 * n, p[1]);
      int log2n = __lg(2 * n);
  
      vector<ll> presum(k + 1);
      ffor(1, k + 1, 1) presum[i] = (presum[i - 1] + i) % mod;
  
      for (int i = 2; i <= n; i++) {
          ll y = p[i];
          for (int z = 0, z2 = 1; z <= log2n; z++, z2 <<= 1) {
              if (y > z2 && k - z - 1 > 0) {
                  ll x = stQuery(ST, 1, 1, 2 * n, (y / (z2 * 2)) + 1, (y / z2) + 1) % mod;
                  sum = (sum + (x * presum[k - z - 1]) % mod) % mod;
              }
              if (y * z2 < 2 * n) {
                  ll x = stQuery(ST, 1, 1, 2 * n, y * z2, y * z2 * 2) % mod;
                  if (z + 1 > k) 
                      sum = (sum + (x * k % mod * k % mod)) % mod;
                  else 
                      sum = (sum + (x * (z * k % mod + (presum[k] - presum[z] + mod) % mod)) % mod) % mod;
              }
          }
          stUpdate(ST, 1, 1, 2 * n, y);
      }
      return sum;
  }
  
  int main () {
      ios::sync_with_stdio(false); cin.tie(0);
      int t;  cin >> t;
      while (t--) {
          cout << solve() << '\n';
      }
  }
  ```

</details>

<br>

## [F: Construct Tree](https://codeforces.com/problemset/problem/1917/F)

<details>
  <summary>tags</summary>
  
    | dp | bitmask |

</details>

<details>
  <summary>solution</summary>

    The core concept is: 
      given the length of one side of the diameter, edges longer than that should be on the other side of the diameter.
      
    Consider a case where left side has length L, edges longer than L sums P.
    What we have to do is to determine if we can form length L and (d - L - P) with edges shorter than L.
    Use a vector of bitset dp[x][bs] to solve this.  x is the L, while each bit in bs indicates if len=bit is viable.

    Assume that L is the shorter side of the diameter.
    For every L in [1, d/2], include the shorter len[i]s into dp, and see if dp[L][d - L - sufsum[i]] is true.

    See comments in code for more details.
    
</details>

<details>
  <summary>code</summary>

  ```c++
  const ll D = 2005;  
  int main () {
      ios::sync_with_stdio(false); cin.tie(0);
      int t;  cin >> t;
      while (t--) {
          int n, d;  cin >> n >> d;
          vector<int> len(n + 1);
          for (int i = 1; i <= n; i++) cin >> len[i];
          sort(len.begin() + 1, len.end());
  
          vector<int> sufsum(n + 2);
          for (int i = n; i > 0; i--) sufsum[i] = sufsum[i + 1] + len[i];
  
          vector< bitset<D> > dp(D / 2);
          // dp[x][bitset]: left side with length x, right side's possible length shown as bitset
          dp[0][0] = 1;
  
          bool ok = false;
          for (int L = 1, i = 1; L <= d / 2; L++) {  // left side has length L
              while (i <= n && len[i] <= L) {
                  for (int x = d / 2; x >= 0; x--) {
                      if (x + len[i] <= d / 2) dp[x + len[i]] |= dp[x];  // add len[i] to the left
                      dp[x] |= (dp[x] << len[i]);  // add len[i] to the right
                  }
                  i++;
              }
              // Now we are putting the rest len[i] larger than L **all** to the right,
              // because they will form a longer diameter if they are not in the diameter
  
              // And still we need (d - sufsum[i] - L) to complete the length (d - L)
              // If dp[x][d - sufsum[i] - L] is true, then it's ok to do so
  
              // And since the len[i] that are not in the diameter are all smaller than L, ignore them
  
              int R = d - sufsum[i] - L;
              if (R >= 0 && dp[L][R]) {
                  ok = true;
                  break;
              }
          }
          if (ok) cout << "yes\n";
          else cout << "no\n";
      }
  }
  ```

</details>

<br>
